# MYSQL中的B+tree

## B-tree

B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

一棵m阶的B-Tree有如下特性： 

1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)



![img](assets/20160202204827368)



每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：

1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。



## B+tree

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 
![索引](assets/20160202205105560)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

### B+tree 插入操作

#### 插入操作基本原则

插入操作是指插入一条记录，即（key, value）的键值对。如果B+树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B+树不存在这个key,则一定是在叶子结点中进行插入操作。

1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。

2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。

3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。

下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key







![1569484617423](assets/1569484617423.png)

##### 加入28操作

找到对应叶子节点，插入后发现叶子节点没满，直接结束。

![1569484697295](assets/1569484697295.png)



##### 加入70 操作

找到对应叶子节点，插入后发现叶子节点已经满了，获取中间位置记录（60）提出来放到上面父节点，60两侧的数据分别变成60节点的左节点（50,55）和右节点（60,65,70）。检查父节点是否已满，没满则结束。

![1569484986219](assets/1569484986219.png)



![1569486991588](assets/1569486991588.png)



##### 插入95操作

找到对应叶子节点，插入后发现叶子节点已经满了。

![1569487097674](assets/1569487097674.png)



获取中间位置记录（85）提出来放到上面父节点，85两侧的数据分别变成85节点的左节点（75,80）和右节点（85，90，95）。

![1569488493348](assets/1569488493348.png)

检查父节点是否已满，发现父节点已满，则继续拆分，提出60，两侧分别是60



![1569487925171](assets/1569487925171.png)



### B+tree删除操作

B+树使用填充因子来控制数的删除变化，50%的填充因子是可设的最小值。

| 叶子节点小于填充因子 | 中间节点小于填充因子 | 操作                                                         |
| -------------------- | -------------------- | ------------------------------------------------------------ |
| No                   | no                   | 直接将记录从叶子节点删除，如果该节点还是Index page的节点，用该节点的右节点代替 |
| Yes                  | No                   | 合并叶子节点和他的兄弟节点，同时更新Index page               |
| Yes                  | Yes                  | 1：合并叶子节点和他的兄弟节点<br />2：更新Index page<br />3：合并IndexPage 和他的兄弟节点 |

删除70 记录：

要删除70 看表格，叶子节点和中间节点都没有小于填充因子，直接删除就行，删除后如下：

![1569565749192](assets/1569565749192.png)



删除25：

![1569566902766](assets/1569566902766.png)

将25从叶子节点删除，但是因为25还是index值，所以将25的右侧兄弟节点放到25在index的位置中。

删除60的情况：

因为删除60之后，叶子节点少于容量的50%，所以，叶子节点需要合并。处理后的情况如下：

![1569567347520](assets/1569567347520.png)

## B+tree索引

​		数据库中的B+Tree索引可以分为**聚集索引**（clustered index）和**辅助索引**（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

### 聚集索引



### 辅助索引





